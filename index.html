<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRT Merger (Offline)</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0071e3">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f5f5f7;
            --container-bg: #ffffff;
            --text-primary: #1d1d1f;
            --text-secondary: #86868b;
            --accent-color: #0071e3;
            --accent-hover: #0077ed;
            --border-color: #d2d2d7;
            --code-bg: #f5f5f7;
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #000000;
                --container-bg: #1c1c1e;
                --text-primary: #f5f5f7;
                --text-secondary: #86868b;
                --accent-color: #2997ff;
                --accent-hover: #0071e3;
                --border-color: #424245;
                --code-bg: #2c2c2e;
                --shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            }
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.5;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            background: var(--container-bg);
            padding: 40px;
            border-radius: 18px;
            box-shadow: var(--shadow);
        }

        h1 {
            margin-top: 0;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .badge {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 16px;
            background: rgba(0, 113, 227, 0.1);
            color: var(--accent-color);
        }

        .instructions-container {
            display: flex;
            align-items: center;
            gap: 40px;
            margin: 30px 0;
            padding: 20px;
            background: var(--bg-color);
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .instructions-text {
            flex: 1;
        }

        .instructions-text p {
            margin: 12px 0;
            color: var(--text-primary);
        }

        .instructions-text code {
            background: rgba(0, 0, 0, 0.05);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        @media (prefers-color-scheme: dark) {
            .instructions-text code {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .instructions-image {
            flex: 1;
            text-align: center;
        }

        .instructions-image svg {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .upload-area {
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--bg-color);
            margin-top: 30px;
        }

        .upload-area:hover {
            border-color: var(--accent-color);
            background: rgba(0, 113, 227, 0.05);
            transform: scale(1.01);
        }

        .upload-area strong {
            font-size: 1.2em;
            color: var(--accent-color);
        }

        #log {
            margin-top: 25px;
            padding: 20px;
            background: var(--code-bg);
            border-radius: 8px;
            font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
            white-space: pre-wrap;
            height: 200px;
            overflow-y: auto;
            font-size: 13px;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 980px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            display: none;
            margin-top: 25px;
            transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
        }

        #preview-container {
            margin-top: 40px;
            display: none;
        }

        #preview-content {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            font-size: 13px;
            color: var(--text-primary);
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid rgba(0, 0, 0, 0.1);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border-left-color: var(--accent-color);
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .instructions-container {
                flex-direction: column-reverse;
                gap: 20px;
                text-align: center;
            }

            .upload-area {
                padding: 40px 20px;
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <span class="badge">Run Locally â€¢ No Uploads</span>
        <h1>SRT Video Merger</h1>

        <div class="instructions-container">
            <div class="instructions-text">
                <p>1. Select a folder containing <strong>only</strong> your sequential <code>.srt</code> and
                    <code>.mov</code> files.
                </p>
                <p>2. Files must have <strong>identical names</strong> (excluding extension) to be paired correctly.</p>
                <p style="font-size: 0.9em; color: var(--text-secondary);">Processing happens instantly in your browser.
                </p>
            </div>
            <div class="instructions-image">
                <!-- Embedded SVG for Offline Capability -->
                <svg xmlns="http://www.w3.org/2000/svg" width="400" height="300" viewBox="0 0 400 300"
                    style="background: transparent;">
                    <rect width="400" height="300" fill="#f5f5f7" rx="12" ry="12" style="fill: var(--code-bg);" />
                    <text x="20" y="30" font-family="-apple-system, sans-serif" font-size="14" font-weight="bold"
                        fill="#333" style="fill: var(--text-primary);">Correct Folder Structure Example:</text>
                    <rect x="20" y="45" width="360" height="235" fill="white" stroke="#e0e0e0" rx="8" ry="8"
                        style="fill: var(--container-bg); stroke: var(--border-color);" />
                    <g transform="translate(40, 60)">
                        <rect width="320" height="26" fill="#f0f7ff" rx="4" style="fill: var(--bg-color);" />
                        <text x="10" y="18" font-family="monospace" font-size="13" fill="#333"
                            style="fill: var(--text-primary);">video_01.mov</text>
                        <path d="M290 13 L300 21 L315 5" stroke="#28a745" stroke-width="2" fill="none" />
                    </g>
                    <g transform="translate(40, 92)">
                        <rect width="320" height="26" fill="#f0f7ff" rx="4" style="fill: var(--bg-color);" />
                        <text x="10" y="18" font-family="monospace" font-size="13" fill="#333"
                            style="fill: var(--text-primary);">video_01.srt</text>
                        <path d="M290 13 L300 21 L315 5" stroke="#28a745" stroke-width="2" fill="none" />
                    </g>
                    <path d="M20 73 L35 73 L35 105 L20 105" stroke="#0071e3" stroke-width="2" fill="none"
                        style="stroke: var(--accent-color);" />
                    <text x="200" y="140" text-anchor="middle" font-weight="bold" fill="#ccc">...</text>
                    <g transform="translate(40, 155)">
                        <rect width="320" height="26" fill="#f0f7ff" rx="4" style="fill: var(--bg-color);" />
                        <text x="10" y="18" font-family="monospace" font-size="13" fill="#333"
                            style="fill: var(--text-primary);">video_10.mov</text>
                        <path d="M290 13 L300 21 L315 5" stroke="#28a745" stroke-width="2" fill="none" />
                    </g>
                    <g transform="translate(40, 187)">
                        <rect width="320" height="26" fill="#f0f7ff" rx="4" style="fill: var(--bg-color);" />
                        <text x="10" y="18" font-family="monospace" font-size="13" fill="#333"
                            style="fill: var(--text-primary);">video_10.srt</text>
                        <path d="M290 13 L300 21 L315 5" stroke="#28a745" stroke-width="2" fill="none" />
                    </g>
                    <path d="M20 168 L35 168 L35 200 L20 200" stroke="#0071e3" stroke-width="2" fill="none"
                        style="stroke: var(--accent-color);" />
                    <text x="50" y="240" font-family="-apple-system, sans-serif" font-size="12" fill="#666"
                        style="font-style: italic; fill: var(--text-secondary);">
                        All pairs must match by name
                    </text>
                    <text x="50" y="260" font-family="-apple-system, sans-serif" font-size="12" fill="#d9534f">
                        Folder should contain NOTHING else!
                    </text>
                </svg>
            </div>
        </div>

        <div class="upload-area" onclick="document.getElementById('dirInput').click()">
            <div style="font-size: 2em; margin-bottom: 10px;">ðŸ“‚</div>
            <strong>Click here to Select Folder</strong>
            <p style="color: var(--text-secondary);">or drag and drop folder here</p>
        </div>

        <input type="file" id="dirInput" webkitdirectory directory multiple style="display:none">

        <div id="log">
            <span class="spinner" id="spinner"></span>
            <span id="log-text">Waiting for input...</span>
        </div>

        <button id="downloadBtn" onclick="downloadResult()">Download Merged SRT</button>

        <div id="preview-container">
            <h3>Merged SRT Preview</h3>
            <div id="preview-content"></div>
        </div>
    </div>

    <script>
        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('Service Worker registered', reg))
                    .catch(err => console.log('Service Worker failed', err));
            });
        }

        let mergedContent = "";
        let mergedFileName = "merged_subtitles.srt";
        const logText = document.getElementById('log-text');
        const spinner = document.getElementById('spinner');

        // Utility: Natural Sort
        const naturalSort = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' }).compare;

        function log(msg, isLoading = false) {
            logText.textContent = msg;
            if (isLoading) {
                spinner.style.display = 'inline-block';
            } else {
                spinner.style.display = 'none';
            }
        }

        function appendLog(msg) {
            logText.textContent += "\n" + msg;
        }

        // 1. Handle File Selection
        document.getElementById('dirInput').addEventListener('change', async (e) => {
            handleFiles(Array.from(e.target.files));
        });

        // Drag and Drop support
        const dropArea = document.querySelector('.upload-area');

        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'var(--accent-color)';
            dropArea.style.background = 'rgba(0, 113, 227, 0.1)';
        });

        dropArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'var(--border-color)';
            dropArea.style.background = 'var(--bg-color)';
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'var(--border-color)';
            dropArea.style.background = 'var(--bg-color)';

            // Basic FileList support (folders dropped often come as empty/files depending on browser)
            // Ideally we use webkitGetAsEntry for folders, but let's try basic file processing first
            // or just use the input trigger.
            const items = e.dataTransfer.items;
            if (items) {
                // Logic to scan directory from dataTransfer items is complex cross-browser.
                // For now, simpler to rely on file input or just process whatever files came in.
                const files = [];
                for (let i = 0; i < items.length; i++) {
                    if (items[i].kind === 'file') {
                        const file = items[i].getAsFile();
                        files.push(file);
                    }
                }
                if (files.length > 0) handleFiles(files);
            } else {
                handleFiles(Array.from(e.dataTransfer.files));
            }
        });

        async function handleFiles(files) {
            if (files.length === 0) return;
            log("Found " + files.length + " files. Scanning...", true);

            // Small delay to allow UI to update
            setTimeout(() => processFiles(files), 50);
        }

        // 2. Extract number from filename
        function extractNumber(filename) {
            const matchStart = filename.match(/^(\d+)/);
            if (matchStart) return parseInt(matchStart[1]);

            const matchEnd = filename.match(/(\d+)(?:\.[^.]+)?$/);
            if (matchEnd) return parseInt(matchEnd[1]);

            return null;
        }

        // 3. Time Helpers
        function timeToMs(timeStr) {
            const [h, m, s_ms] = timeStr.split(':');
            const [s, ms] = s_ms.split(',');
            return (parseInt(h) * 3600000) + (parseInt(m) * 60000) + (parseInt(s) * 1000) + parseInt(ms);
        }

        function msToTime(duration) {
            const ms = Math.floor(duration % 1000);
            duration = (duration - ms) / 1000;
            const s = Math.floor(duration % 60);
            duration = (duration - s) / 60;
            const m = Math.floor(duration % 60);
            const h = Math.floor((duration - m) / 60);

            const pad = (n, z = 2) => ('00' + n).slice(-z);
            return `${pad(h)}:${pad(m)}:${pad(s)},${pad(ms, 3)}`;
        }

        // 4. Get Video Duration via Browser
        function getVideoDuration(file) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';

                video.onloadedmetadata = function () {
                    window.URL.revokeObjectURL(video.src);
                    resolve(video.duration * 1000);
                }

                video.onerror = function () {
                    resolve(0);
                }

                video.src = URL.createObjectURL(file);
            });
        }

        function getSmartFilename(firstFile, lastFile) {
            const firstName = firstFile.name;
            const lastName = lastFile.name;

            const startRegex = /^(\d+)/;
            let match = firstName.match(startRegex);
            if (match) {
                const firstNum = match[1];
                const lastMatch = lastName.match(startRegex);
                const lastNum = lastMatch ? lastMatch[1] : '';
                if (lastNum) {
                    return firstName.replace(startRegex, `${firstNum}-${lastNum}`);
                }
            }

            const endRegex = /(\d+)(?:\.[^.]+)?$/;
            match = firstName.match(endRegex);
            if (match) {
                const firstNum = match[1];
                const lastMatch = lastName.match(endRegex);
                const lastNum = lastMatch ? lastMatch[1] : '';
                if (lastNum) {
                    return firstName.replace(endRegex, (m, n) => m.replace(n, `${n}-${lastNum}`));
                }
            }

            return "merged_subtitles.srt";
        }

        // 5. Main Processing Logic
        // 5. Main Processing Logic
        async function processFiles(fileList) {
            document.getElementById('downloadBtn').style.display = 'none';
            document.getElementById('preview-container').style.display = 'none';
            document.getElementById('preview-content').textContent = '';

            // Reset Log
            logText.style.color = 'var(--text-secondary)';
            logText.textContent = 'Analyzing files...';
            spinner.style.display = 'inline-block';

            const validExtensions = ['.srt', '.mov'];
            const ignoredFiles = ['.ds_store']; // lowercase

            const extraFiles = [];
            const pairs = {};

            // 1. Initial Scan & Validation
            for (let f of fileList) {
                const name = f.name;
                const lowerName = name.toLowerCase();

                // Check if file is in a subfolder (e.g. "Root/Sub/file.txt" has > 2 parts)
                // We only want files in the root of the selection ("Root/file.txt")
                if (f.webkitRelativePath && f.webkitRelativePath.split('/').length > 2) {
                    continue;
                }

                // Skip hidden/system files
                if (name.startsWith('.') || ignoredFiles.includes(lowerName)) continue;

                // Check extension
                const isSrt = lowerName.endsWith('.srt');
                const isMov = lowerName.endsWith('.mov');

                if (!isSrt && !isMov) {
                    extraFiles.push(name);
                    continue;
                }

                const num = extractNumber(name);
                if (num === null) {
                    extraFiles.push(name + " (no number found)");
                    continue;
                }

                if (!pairs[num]) pairs[num] = { id: num };

                if (isSrt) {
                    if (pairs[num].srt) extraFiles.push(name + " (duplicate ID)");
                    else pairs[num].srt = f;
                } else if (isMov) {
                    if (pairs[num].mov) extraFiles.push(name + " (duplicate ID)");
                    else pairs[num].mov = f;
                }
            }

            // 2. Report Extra Files Error
            if (extraFiles.length > 0) {
                logError("Error: Folder contains unsupported or extra files:\n" + extraFiles.join("\n"));
                return;
            }

            // 3. Check for Mismatched Pairs
            const sortedPairs = Object.values(pairs).sort((a, b) => a.id - b.id);
            const mismatched = sortedPairs.filter(p => !p.srt || !p.mov);

            if (mismatched.length > 0) {
                const details = mismatched.map(p => {
                    const existing = p.srt ? p.srt.name : p.mov.name;
                    return `ID ${p.id}: Found ${existing}, but missing counterpart.`;
                }).join("\n");
                logError("Error: Mismatched pairs found.\n" + details);
                return;
            }

            if (sortedPairs.length === 0) {
                logError("Error: No valid SRT/MOV pairs found.");
                return;
            }

            mergedFileName = getSmartFilename(sortedPairs[0].srt, sortedPairs[sortedPairs.length - 1].srt);
            log(`Processing ${sortedPairs.length} pairs... Output: ${mergedFileName}`, true);

            let cumulativeDuration = 0;
            let finalSrtContent = "";
            let globalIndex = 1;

            try {
                for (let i = 0; i < sortedPairs.length; i++) {
                    const pair = sortedPairs[i];

                    if (i > 0) {
                        const prevMov = sortedPairs[i - 1].mov;
                        const duration = await getVideoDuration(prevMov);
                        cumulativeDuration += duration;
                    }

                    const text = await pair.srt.text();

                    // Regex corrected: (\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})
                    const shiftedText = text.replace(
                        /(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/g,
                        (match, start, end) => {
                            const newStart = msToTime(timeToMs(start) + cumulativeDuration);
                            const newEnd = msToTime(timeToMs(end) + cumulativeDuration);
                            return `${newStart} --> ${newEnd}`;
                        }
                    );

                    const blocks = shiftedText.replace(/\r\n/g, '\n').replace(/\n{3,}/g, '\n\n').split('\n\n');

                    for (let block of blocks) {
                        block = block.trim();
                        if (!block) continue;

                        const lines = block.split('\n');
                        // Remove old index if present
                        if (lines.length > 0 && /^\d+$/.test(lines[0].trim())) {
                            lines.shift();
                        }

                        finalSrtContent += `${globalIndex}\n${lines.join('\n')}\n\n`;
                        globalIndex++;
                    }
                }

                mergedContent = finalSrtContent;
                log("Done! Ready to download.", false);
                document.getElementById('downloadBtn').style.display = 'inline-block';

                document.getElementById('preview-content').textContent = mergedContent;
                document.getElementById('preview-container').style.display = 'block';

            } catch (err) {
                logError("Unexpected error during processing: " + err.message);
                console.error(err);
            }
        }

        function logError(msg) {
            logText.textContent = msg;
            logText.style.color = '#d9534f'; // Red for error
            spinner.style.display = 'none';
        }

        function downloadResult() {
            const blob = new Blob([mergedContent], { type: 'text/srt' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = mergedFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    </script>
</body>

</html>